import os
import sys
import json
import re
import uuid
from typing import Dict, List, Any, Optional, Union
import time
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed

# Import the progress monitoring system
try:
    from progress_server import (
        send_progress_update,
        check_server_health
    )
    WEBSOCKET_AVAILABLE = True
    
    # Check if server is running
    def is_server_running():
        """Check if server is running"""
        health = check_server_health()
        return health.get('running', False)
        
except ImportError:
    WEBSOCKET_AVAILABLE = False
    print("[WARNING] WebSocket progress server not available", file=sys.stderr)


class MappingGenerator:
    """Generates file mappings based on configurable VFX patterns."""

    def __init__(self, config_path: str = None):
        if config_path is None:
            script_dir = Path(__file__).parent.parent
            config_path = script_dir / "src" / "config" / "patterns.json"
        self.config = self._load_config(config_path)
        self.shot_patterns = [
            re.compile(pattern, re.IGNORECASE)
            for pattern in self.config.get("shotPatterns", [])
        ]
        self.task_patterns = self.config.get("taskPatterns", {})
        self.resolution_patterns = self.config.get("resolutionPatterns", [])
        self.version_patterns = [
            re.compile(pattern, re.IGNORECASE)
            for pattern in self.config.get("versionPatterns", [])
        ]
        self.project_types = self.config.get("projectTypes", {})
        self.max_depth = 10
        self.current_frame_numbers = []  # Initialize frame numbers storage

    def _load_config(self, config_path: str) -> Dict[str, Any]:
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config = json.load(f)
                print(f"Loaded patterns config from: {config_path}", file=sys.stderr)
                return config
        except Exception as e:
            print(f"Failed to load config from {config_path}: {e}", file=sys.stderr)
            print("Using fallback patterns", file=sys.stderr)
            return {
                "shotPatterns": ["DEMO\\d{4}", "FULL\\d{4}", "ANOT\\d{4}", "\\d{3,4}"],
                "taskPatterns": {
                    "comp": ["comp", "composite"],
                    "vfx": ["vfx", "effects"],
                    "footage": ["footage", "plates"],
                },
                "resolutionPatterns": ["2k", "4k", "hd", "proxy"],
                "versionPatterns": ["v\\d{3}", "_v\\d{2,3}"],
                "projectTypes": {
                    "sphere": {"vfxFolder": "04_vfx", "compFolder": "05_comp"},
                    "internal": {"footageFolder": "footage", "3dFolder": "3d"},
                },
            }

    def _extract_shot_simple(self, filename: str, path: str) -> Optional[str]:
        for pattern in self.shot_patterns:
            match = pattern.search(filename)
            if match:
                return match.group(0)
        return "unmatched"

    def _extract_task_simple(self, filename: str, path: str) -> Optional[str]:
        for canonical, patterns in self.task_patterns.items():
            for pattern in patterns:
                if re.search(
                    rf"(?<![a-zA-Z0-9]){re.escape(pattern)}(?![a-zA-Z0-9])",
                    filename,
                    re.IGNORECASE,
                ):
                    return canonical
        return "unmatched"

    def _extract_version_simple(self, filename: str) -> Optional[str]:
        # Use a broad regex for v1, v01, v001, v0001, etc.
        pattern = re.compile(r"[_\.]?v\d{1,6}", re.IGNORECASE)
        matches = [m.group(0).lstrip("_.") for m in pattern.finditer(filename)]
        if matches:
            return matches[-1]
        else:
            return "unmatched"

    def _extract_resolution_simple(self, filename: str, path: str) -> Optional[str]:
        for resolution in self.resolution_patterns:
            if re.search(re.escape(resolution), filename, re.IGNORECASE):
                return resolution
        return "unmatched"

    def _extract_asset_simple(self, filename: str) -> Optional[str]:
        asset_patterns = self.config.get("assetPatterns", [])
        for asset in asset_patterns:
            if re.search(
                rf"(?<![a-zA-Z0-9]){re.escape(asset)}(?![a-zA-Z0-9])",
                filename,
                re.IGNORECASE,
            ):
                return asset
        return "unmatched"

    def _extract_stage_simple(self, filename: str) -> Optional[str]:
        stage_patterns = self.config.get("stagePatterns", [])
        for stage in stage_patterns:
            if re.search(
                rf"(?<![a-zA-Z0-9]){re.escape(stage)}(?![a-zA-Z0-9])",
                filename,
                re.IGNORECASE,
            ):
                return stage
        return "unmatched"

    def _update_mapping_progress(self, batch_id, current, total, status="processing", current_file=""):
        """Update mapping progress using WebSocket server"""
        try:
            # Calculate percentage
            percentage = round(current / total * 100 if total > 0 else 0, 1)
            
            # Log progress
            print(f"[PROGRESS] {status}: {current}/{total} ({percentage}%)", file=sys.stderr)
            
            # Use WebSocket server if available
            if WEBSOCKET_AVAILABLE and is_server_running():
                try:
                    # Ensure batch_id includes a prefix for operation type if not already present
                    actual_batch_id = batch_id
                    if batch_id and '-' not in batch_id:
                        actual_batch_id = f"map-{batch_id}"
                    
                    # Send progress update via WebSocket
                    send_progress_update(
                        batch_id=actual_batch_id,
                        files_processed=current,
                        total_files=total,
                        current_file=current_file,
                        status=status
                    )
                    return True
                except Exception as e:
                    print(f"[WARNING] WebSocket progress update failed: {str(e)}", file=sys.stderr)
                    # Fall through to file-based progress
            
            # Fallback to file-based progress
            progress_dir = Path(os.environ.get('TEMP', '/tmp')) / 'folder_normalizer'
            progress_dir.mkdir(exist_ok=True)
            progress_file = progress_dir / f"mapping_progress_{batch_id}.json"
            
            progress_data = {
                "current": current,
                "total": total,
                "percentage": percentage,
                "status": status,
                "currentFile": current_file,
                "timestamp": time.time()
            }
            
            with open(progress_file, 'w') as f:
                json.dump(progress_data, f)
        except Exception as e:
            print(f"Error updating mapping progress: {e}", file=sys.stderr)
    
    def generate_mappings(
        self, tree: Dict[str, Any], profile: Dict[str, Any], batch_id=None, websocket_available=None
    ) -> List[Dict[str, Any]]:
        print(f"=== MAPPING GENERATION STARTED ===", file=sys.stderr)
        print(f"Profile: {profile.get('name', 'Unknown')}", file=sys.stderr)
        print(f"VFX Root: {profile.get('vfxRootPath', '/vfx/projects/default')}", file=sys.stderr)
        print(f"Tree: {tree.get('name', 'Unknown')} (type: {tree.get('type', 'unknown')})", file=sys.stderr)
        children = tree.get("children", [])
        print(f"Processing {len(children)} items", file=sys.stderr)
        
        # Initialize progress tracking
        if batch_id:
            self._update_mapping_progress(batch_id, 0, 100, status="initializing")  # Initial progress
        all_files = []

        # Check if tree has _all_files (folders-only mode with file list)
        if "_all_files" in tree and tree["_all_files"]:
            print(f"Using _all_files list from folders-only tree", file=sys.stderr)
            # Convert file paths to file nodes
            for file_path in tree["_all_files"]:
                try:
                    path_obj = Path(file_path)
                    stat_info = path_obj.stat()
                    file_node = {
                        "name": path_obj.name,
                        "path": str(path_obj),
                        "type": "file",
                        "size": stat_info.st_size,
                        "extension": path_obj.suffix.lower(),
                    }
                    all_files.append(file_node)
                except Exception as e:
                    print(f"Error processing file {file_path}: {e}", file=sys.stderr)
                    continue
        else:
            # Traditional tree traversal for trees with file nodes
            def collect_files(node):
                node_type = node.get("type", "unknown")
                if node_type == "file":
                    all_files.append(node)
                elif node_type == "folder":
                    children = node.get("children", [])
                    for child in children:
                        collect_files(child)

            collect_files(tree)
        
        print(f"Collected {len(all_files)} total files", file=sys.stderr)
        
        # Update progress - 25% complete after collecting files
        if batch_id:
            self._update_mapping_progress(batch_id, 25, 100, status="files_collected")
            
        # Group image sequences with progress reporting
        sequences, single_files = self._group_image_sequences(all_files, batch_id)
        print(f"Found {len(sequences)} image sequences and {len(single_files)} single files", file=sys.stderr)
        
        # Update progress - 50% complete after grouping sequences
        if batch_id:
            self._update_mapping_progress(batch_id, 50, 100, status="generating_mappings")
        # Process files in parallel for better performance
        mappings = []
        total_items = len(sequences) + len(single_files)
        processed = 0
        
        # Print progress information
        print(f"[INFO] Starting to process {len(sequences)} sequences and {len(single_files)} single files", file=sys.stderr)
        
        # Process sequences first (they're typically more important)
        sequence_errors = 0
        for idx, sequence in enumerate(sequences):
            try:
                # Extract original base_name from sequence if available
                original_base_name = None
                if isinstance(sequence, dict) and "base_name" in sequence:
                    original_base_name = sequence.get("base_name")
                    print(f"[DEBUG] Found original base_name in sequence dict: {original_base_name}", file=sys.stderr)
                    
                # For list-type sequences, try to extract base_name from filenames
                elif isinstance(sequence, list) and len(sequence) > 0:
                    # Try to find a good candidate for base_name from the files
                    for file_item in sequence[:10]:  # Check first 10 files
                        if isinstance(file_item, str) and os.path.basename(file_item):
                            filename = os.path.basename(file_item)
                            # Check if this is a good candidate for base_name extraction
                            seq_info = self._extract_sequence_info(filename)
                            if seq_info and seq_info.get("base_name"):
                                original_base_name = seq_info.get("base_name")
                                print(f"[DEBUG] Extracted original base_name from list item: {original_base_name}", file=sys.stderr)
                                break
                        elif isinstance(file_item, dict) and file_item.get("name"):
                            filename = file_item.get("name")
                            # Check if this is a good candidate for base_name extraction
                            seq_info = self._extract_sequence_info(filename)
                            if seq_info and seq_info.get("base_name"):
                                original_base_name = seq_info.get("base_name")
                                print(f"[DEBUG] Extracted original base_name from dict item: {original_base_name}", file=sys.stderr)
                                break
                
                # Create the sequence mapping with the original base_name if we found one
                seq_mapping = self._create_sequence_mapping(sequence, profile, original_base_name)
                if isinstance(seq_mapping, list):
                    mappings.extend(seq_mapping)
                    processed += len(seq_mapping)
                elif seq_mapping:
                    mappings.append(seq_mapping)
                    processed += 1
                    
                    # Update progress periodically - from 50% to 75% during sequence processing
                    if batch_id and processed % max(1, min(100, len(sequences) // 10)) == 0:
                        progress = 50 + (processed / total_items * 25)
                        # Safely get sequence info for progress reporting
                        if isinstance(sequence, dict):
                            current_file = f"{sequence.get('base_name', '')} {sequence.get('suffix', '')}"
                        else:
                            current_file = "sequence_" + str(idx)
                        self._update_mapping_progress(batch_id, int(progress), 100, status="processing_sequences", current_file=current_file)
                        print(f"[PROGRESS] Sequence mapping: {idx+1}/{len(sequences)} ({(idx+1)/len(sequences)*100:.1f}%)", file=sys.stderr)
            except Exception as e:
                sequence_errors += 1
                # Safely access sequence information
                seq_name = "unknown"
                if isinstance(sequence, dict):
                    seq_name = sequence.get('base_name', 'unknown')
                elif isinstance(sequence, list) and len(sequence) > 0:
                    if isinstance(sequence[0], dict) and 'name' in sequence[0]:
                        seq_name = sequence[0]['name']
                    elif isinstance(sequence[0], str):
                        seq_name = os.path.basename(sequence[0])
                print(f"[ERROR] Failed to process sequence {seq_name}: {str(e)}", file=sys.stderr)
                # Continue with next sequence
                continue
        
        if sequence_errors > 0:
            print(f"[WARNING] Failed to process {sequence_errors} sequences", file=sys.stderr)
        
        print(f"[INFO] Completed sequence processing, starting parallel file processing", file=sys.stderr)
        
        # Process single files with parallel execution for better performance
        max_workers = min(16, os.cpu_count() * 2)  # Limit max workers to avoid overwhelming the system
        print(f"[INFO] Using {max_workers} parallel workers for file processing", file=sys.stderr)
        
        try:
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                # Submit all tasks
                future_to_file = {executor.submit(self._create_simple_mapping, file_node, profile): file_node 
                                for file_node in single_files}
                
                # Process as they complete
                file_errors = 0
                for i, future in enumerate(as_completed(future_to_file)):
                    try:
                        mapping = future.result(timeout=10)  # Add timeout to prevent hanging on a single file
                        mappings.append(mapping)
                        processed += 1
                    except Exception as e:
                        file_errors += 1
                        file_name = future_to_file[future].get('name', 'unknown')
                        print(f"[ERROR] Failed to process file {file_name}: {str(e)}", file=sys.stderr)
                    
                    # Update progress periodically - from 75% to 95% during single file processing
                    if batch_id and i % max(1, min(500, len(single_files) // 20)) == 0:
                        progress = 75 + (i / len(single_files) * 20)
                        current_file = future_to_file[future].get('name', '')
                        self._update_mapping_progress(batch_id, int(progress), 100, status="processing_files", current_file=current_file)
                        print(f"[PROGRESS] File mapping: {i+1}/{len(single_files)} ({(i+1)/len(single_files)*100:.1f}%)", file=sys.stderr)
                
                if file_errors > 0:
                    print(f"[WARNING] Failed to process {file_errors} files", file=sys.stderr)
        except Exception as e:
            print(f"[ERROR] Error in parallel processing: {str(e)}", file=sys.stderr)
        auto_mapped = len([m for m in mappings if m.get("status") == "auto"])
        manual_mapped = len([m for m in mappings if m.get("status") == "manual"])
        sequence_count = len([m for m in mappings if m.get("type") == "sequence"])
        print(f"=== MAPPING SUMMARY ===", file=sys.stderr)
        print(f"Total mappings: {len(mappings)}", file=sys.stderr)
        print(f"Image sequences: {sequence_count}", file=sys.stderr)
        print(f"Single files: {len(mappings) - sequence_count}", file=sys.stderr)
        print(f"Auto-mapped: {auto_mapped}", file=sys.stderr)
        print(f"Manual required: {manual_mapped}", file=sys.stderr)
        
        # Final progress update - 100% complete
        if batch_id:
            self._update_mapping_progress(batch_id, 100, 100, status="complete")
            
        return mappings

    def _init_patterns_from_profile(self, profile: Dict[str, Any]):
        print(
            f"Initializing patterns from profile: {profile.get('name', 'Unknown')}",
            file=sys.stderr,
        )
        user_patterns = profile.get("userPatterns", {})
        shot_names = user_patterns.get("shotNames", [])
        if shot_names:
            shot_patterns = []
            for shot_name in shot_names:
                escaped = re.escape(shot_name)
                shot_patterns.append(escaped)
            shot_patterns.extend(self.config.get("shotPatterns", []))
            self.shot_patterns = [
                re.compile(pattern, re.IGNORECASE) for pattern in shot_patterns
            ]
            print(
                f"Updated shot patterns: {[p.pattern for p in self.shot_patterns]}",
                file=sys.stderr,
            )
        profile_tasks = user_patterns.get("tasks", [])
        if profile_tasks:
            merged_tasks = dict(self.task_patterns)
            for task_info in profile_tasks:
                task_name = task_info.get("name", "")
                aliases = task_info.get("aliases", [])
                if task_name and aliases:
                    merged_tasks[task_name] = aliases
            self.task_patterns = merged_tasks
            print(
                f"Updated task patterns: {list(self.task_patterns.keys())}",
                file=sys.stderr,
            )
        profile_resolutions = user_patterns.get("resolutions", [])
        if profile_resolutions:
            merged_resolutions = list(self.config.get("resolutionPatterns", []))
            for res in profile_resolutions:
                if res not in merged_resolutions:
                    merged_resolutions.append(res)
            self.resolution_patterns = merged_resolutions
            print(
                f"Updated resolution patterns: {self.resolution_patterns}",
                file=sys.stderr,
            )

    def _is_network_path(self, path: str) -> bool:
        """Check if a path is on a network drive"""
        network_prefixes = ('\\\\', '//', 'N:', 'Z:', 'V:')  # Common network drive prefixes
        return any(path.startswith(prefix) for prefix in network_prefixes)
        
    def _group_image_sequences(self, files: List[Dict[str, Any]], batch_id=None):
        """Group image files into sequences based on naming patterns.
        
        Args:
            files: List of file nodes to process
            batch_id: Optional batch ID for progress tracking
            
        Returns:
            Tuple of (sequences, single_files)
        """
        import concurrent.futures
        from threading import Lock
        
        # Set of extensions that can be part of an image sequence
        sequence_extensions = set([
            # Image formats - include with and without dot prefix
            "exr", ".exr", "dpx", ".dpx", "tif", ".tif", "tiff", ".tiff", 
            "jpg", ".jpg", "jpeg", ".jpeg", "png", ".png", "hdr", ".hdr",
            # Add any other formats that might be part of sequences in your workflow
            "mov", ".mov", "mp4", ".mp4"  # Sometimes video frames are also in sequences
        ])
        print(f"[SEQUENCE_DEBUG] Sequence extensions: {sequence_extensions}", file=sys.stderr)
        
        # Initialize tracking variables
        file_groups = {}
        file_groups_lock = Lock()  # For thread safety
        single_files = []
        single_files_lock = Lock()  # For thread safety
        total_files = len(files)
        progress_interval = 20  # Report progress every N files
        
        # Check if path is on a network drive and use optimized parameters
        is_network = False
        if total_files > 0 and "path" in files[0]:
            is_network = self._is_network_path(files[0]["path"])
            if is_network:
                print(f"[INFO] Network path detected, using optimized sequence grouping", file=sys.stderr)
        
        # Setup progress reporting with more frequent updates for network paths
        progress_update_interval = 0.2 if is_network else 0.5
        last_progress_time = time.time()
        
        # Send initial progress update
        if batch_id:
            self._update_mapping_progress(batch_id, 0, total_files, status="grouping_sequences")
            print(f"[PROGRESS] Sequence grouping: 0/{total_files} (0%)", file=sys.stderr)
        
        # Define a thread-safe worker function for processing files
        def process_file_batch(batch_files, start_idx, progress_lock):
            local_processed = 0
            local_single_files = []
            local_file_groups = {}
            
            for file_idx, file_node in enumerate(batch_files):
                i = start_idx + file_idx  # Overall index
                try:
                    # Process the file for sequence detection
                    file_name = file_node.get("name", "")
                    file_ext = file_node.get("extension", "").lower()
                    
                    # Skip non-sequence file types immediately
                    if file_ext not in sequence_extensions:
                        local_single_files.append(file_node)
                        continue
                        
                    # Get file path and directory
                    file_path = file_node.get("path", "")
                    directory = str(Path(file_path).parent)
                    
                    # Extract sequence information with additional debugging
                    print(f"[SEQUENCE_GROUPING] Processing file: {file_name}", file=sys.stderr)
                    sequence_info = self._extract_sequence_info(file_name)
                    
                    # Log whether sequence info was extracted
                    if sequence_info:
                        print(f"[SEQUENCE_GROUPING] Extracted sequence info: base={sequence_info['base_name']}, frame={sequence_info['frame']}", file=sys.stderr)
                    else:
                        print(f"[SEQUENCE_GROUPING] No sequence info extracted for: {file_name}", file=sys.stderr)
                    
                    if sequence_info and "frame" in sequence_info:
                        # Get sequence key (base_name + ext)
                        base_name = sequence_info["base_name"]
                        filename = file_name
                        # Validate filename in the extracted info
                        if filename:
                            # Debug what we're trying to extract from
                            print(f"[SEQUENCE_DEBUG] Attempting to extract from filename: '{filename}'", file=sys.stderr)
                            
                            # Special handling for empty or placeholder filenames
                            if not filename or filename.strip() == "" or "sequence_" in filename.lower():
                                print(f"[SEQUENCE_DEBUG] Empty or placeholder filename: '{filename}'", file=sys.stderr)
                                return None
                                
                            # This is a regular filename, extract information
                            info = {
                                "base_name": base_name,
                                "frame": sequence_info["frame"],
                                "suffix": file_ext
                            }
                            sequence_info = info
                        else:
                            print(f"[SEQUENCE_DEBUG] Empty filename received in extraction", file=sys.stderr)
                        seq_key = (base_name, file_ext)

                        if seq_key not in local_file_groups:
                            local_file_groups[seq_key] = {
                                "base_name": base_name,
                                "suffix": file_ext,
                                "frames": [],
                                "files": [],
                                "type": "sequence",
                                "size": 0,
                                "file_count": 0,
                                "directory": directory,
                            }
                            
                        # Add frame information
                        local_file_groups[seq_key]["frames"].append(sequence_info["frame"])
                        local_file_groups[seq_key]["files"].append(file_path)
                        local_file_groups[seq_key]["size"] += file_node.get("size", 0)
                        local_file_groups[seq_key]["file_count"] += 1
                    else:
                        # Not a sequence file
                        local_single_files.append(file_node)
                        
                    # Update progress periodically
                    local_processed += 1
                    if local_processed % 20 == 0:
                        with progress_lock:
                            current_time = time.time()
                            nonlocal last_progress_time, processed_count
                            processed_count += 20
                            
                            if processed_count % progress_interval == 0 or (current_time - last_progress_time) > progress_update_interval:
                                progress_percentage = processed_count / total_files * 100
                                if batch_id:
                                    self._update_mapping_progress(
                                        batch_id, processed_count, total_files, 
                                        status="grouping_sequences", 
                                        current_file=file_node.get("name", "")
                                    )
                                if processed_count % (progress_interval * 10) == 0:
                                    print(f"[PROGRESS] Sequence grouping: {processed_count}/{total_files} ({progress_percentage:.1f}%)", file=sys.stderr)
                                last_progress_time = current_time
                                
                except Exception as e:
                    print(f"[ERROR] Error processing file {file_node.get('name', 'unknown')}: {e}", file=sys.stderr)
                    local_single_files.append(file_node)  # Add to single files as fallback
            
            # Return the local results to be merged
            return local_file_groups, local_single_files
        
        # Determine optimal number of workers based on network status and CPU count
        max_workers = 4 if is_network else min(8, os.cpu_count() or 4)
        print(f"[INFO] Using multithreaded processing with {max_workers} workers", file=sys.stderr)
        
        # Setup shared state for progress tracking
        processed_count = 0
        progress_lock = Lock()
        
        # Process files in parallel using multiple threads
        batch_size = 100 if is_network else 200  # Smaller batches for network paths
        
        if total_files > 0:
            try:
                with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
                    # Submit batches of files to the thread pool
                    future_to_batch = {}
                    for batch_start in range(0, total_files, batch_size):
                        batch_end = min(batch_start + batch_size, total_files)
                        batch = files[batch_start:batch_end]
                        future = executor.submit(process_file_batch, batch, batch_start, progress_lock)
                        future_to_batch[future] = (batch_start, batch_end)
                    
                    # Collect results as they complete
                    for future in concurrent.futures.as_completed(future_to_batch):
                        batch_start, batch_end = future_to_batch[future]
                        try:
                            local_file_groups, local_single_files = future.result()
                            
                            # Merge results with the main collections (thread-safe)
                            with file_groups_lock:
                                for key, group in local_file_groups.items():
                                    if key in file_groups:
                                        # Merge with existing group
                                        file_groups[key]["frames"].extend(group["frames"])
                                        file_groups[key]["files"].extend(group["files"])
                                        file_groups[key]["size"] += group["size"]
                                        file_groups[key]["file_count"] += group["file_count"]
                                    else:
                                        # Add new group
                                        file_groups[key] = group
                            
                            with single_files_lock:
                                single_files.extend(local_single_files)
                                
                            print(f"[INFO] Completed batch {batch_start//batch_size + 1}/{(total_files+batch_size-1)//batch_size}", file=sys.stderr)
                            
                        except Exception as e:
                            print(f"[ERROR] Batch processing failed for files {batch_start}-{batch_end}: {e}", file=sys.stderr)
                            # Add all files from the failed batch to single_files as fallback
                            with single_files_lock:
                                single_files.extend(files[batch_start:batch_end])
            except Exception as e:
                print(f"[ERROR] Multithreaded processing failed: {e}", file=sys.stderr)
                print("[INFO] Falling back to single-threaded processing", file=sys.stderr)
                
                # Fallback to single-threaded processing if multithreaded fails
                for i, file_node in enumerate(files):
                    try:
                        self._process_file_for_sequence(file_node, file_groups, single_files, sequence_extensions)
                        
                        # Update progress reporting
                        current_time = time.time()
                        if i % progress_interval == 0 or (current_time - last_progress_time) > progress_update_interval:
                            progress_percentage = (i + 1) / total_files * 100
                            if batch_id:
                                self._update_mapping_progress(
                                    batch_id, i, total_files, 
                                    status="grouping_sequences", 
                                    current_file=file_node.get("name", "")
                                )
                            if i % (progress_interval * 10) == 0:
                                print(f"[PROGRESS] Sequence grouping: {i+1}/{total_files} ({progress_percentage:.1f}%)", file=sys.stderr)
                            last_progress_time = current_time
                    except Exception as e:
                        print(f"[ERROR] Error processing file {file_node.get('name', 'unknown')}: {e}", file=sys.stderr)
                        single_files.append(file_node)  # Add to single files as fallback

        # Finalize all sequences to prepare them for mapping
        sequences = self._finalize_sequences(file_groups, files, single_files, batch_id)
        
        # Final progress update for sequence grouping
        if batch_id:
            self._update_mapping_progress(batch_id, total_files, total_files, status="sequences_grouped")
        
        print(
            f"Found {len(sequences)} sequences with {sum(s['frame_count'] if isinstance(s, dict) and 'frame_count' in s else 0 for s in sequences)} frames",
            file=sys.stderr,
        )
        print(f"Found {len(single_files)} single files", file=sys.stderr)
        return sequences, single_files

    def _process_file_for_sequence(self, file_node, file_groups, single_files, sequence_extensions):
        """Process a single file for sequence grouping"""
        try:
            file_name = file_node.get("name", "")
            
            # Get file extension and handle different formats
            file_ext = file_node.get("extension", "").lower()
            
            # Strip leading dot if present
            if file_ext.startswith("."):
                file_ext = file_ext[1:]
            
            # If extension is empty, try to extract from filename
            if not file_ext and file_name and "." in file_name:
                file_ext = file_name.split(".")[-1].lower()
            
            # Debug info about file extensions
            print(f"[SEQUENCE_DEBUG] File: {file_name}, Extension: '{file_ext}'", file=sys.stderr)
            
            # Check if this is a sequence file type
            is_sequence_type = file_ext in sequence_extensions
            
            # Special handling for common image sequence formats when extension detection fails
            if not is_sequence_type:
                for ext in [".exr", ".dpx", ".tif", ".tiff", ".jpg", ".png"]:
                    if file_name.lower().endswith(ext):
                        is_sequence_type = True
                        file_ext = ext.lstrip('.')
                        print(f"[SEQUENCE_DEBUG] Detected sequence type from filename: {ext}", file=sys.stderr)
                        break
            
            # Check if the filename contains digits that might indicate a sequence
            if not is_sequence_type and any(c.isdigit() for c in file_name):
                # Try to extract sequence info
                sequence_info = self._extract_sequence_info(file_name)
                if sequence_info:
                    is_sequence_type = True
                    print(f"[SEQUENCE_DEBUG] Detected sequence from frame pattern", file=sys.stderr)
            
            # Skip non-sequence file types
            if not is_sequence_type:
                print(f"[SEQUENCE_DEBUG] Not a sequence type: {file_ext}", file=sys.stderr)
                single_files.append(file_node)
                return
                
            # Get file path and directory
            file_path = file_node.get("path", "")
            directory = str(Path(file_path).parent)
            
            # Extract sequence information
            sequence_info = self._extract_sequence_info(file_name)
            
            if sequence_info and "frame" in sequence_info:
                # Get sequence key (base_name + ext)
                base_name = sequence_info["base_name"]
                seq_key = (base_name, file_ext)

                if seq_key not in file_groups:
                    file_groups[seq_key] = {
                        "base_name": base_name,
                        "suffix": file_ext,
                        "frames": [],
                        "files": [],
                        "type": "sequence",
                        "size": 0,
                        "file_count": 0,
                        "directory": directory,
                    }
                    
                # Add frame information
                file_groups[seq_key]["frames"].append(sequence_info["frame"])
                file_groups[seq_key]["files"].append(file_path)
                file_groups[seq_key]["size"] += file_node.get("size", 0)
                file_groups[seq_key]["file_count"] += 1
            else:
                # Not a sequence file
                single_files.append(file_node)
        except Exception as e:
            print(f"[ERROR] Error in _process_file_for_sequence for {file_node.get('name', 'unknown')}: {e}", file=sys.stderr)
            single_files.append(file_node)  # Add to single files as fallback
    
    def _finalize_sequences(self, file_groups, files, single_files, batch_id):
        """Finalize the sequences from grouped files, with timeout protection"""
        sequences = []
        progress_interval = 100
        progress_update_interval = 1.0  # 1 second between updates
        last_progress_time = time.time()
        
        # Report initial status
        print(f"[INFO] Finalizing {len(file_groups)} sequence groups", file=sys.stderr)
        if batch_id:
            self._update_mapping_progress(batch_id, 0, len(file_groups), status="finalizing_sequences")
            
        # Process sequences in batches to avoid memory issues
        for i, (seq_key, group_data) in enumerate(file_groups.items()):
            try:
                # Update progress periodically
                current_time = time.time()
                if i % progress_interval == 0 or (current_time - last_progress_time > progress_update_interval):
                    if batch_id:
                        self._update_mapping_progress(
                            batch_id, i, len(file_groups), 
                            status="finalizing_sequences", 
                            current_file=f"Processing group {i+1}/{len(file_groups)}"
                        )
                    if i % (progress_interval * 10) == 0 or i == 0:
                        print(f"[PROGRESS] Sequence finalization: {i+1}/{len(file_groups)} groups", file=sys.stderr)
                    last_progress_time = current_time
                
                # Skip empty groups
                if not group_data.get("files") or len(group_data["files"]) == 0:
                    continue
                    
                # Sequences need at least 2 frames
                if len(group_data["files"]) > 1:
                    # If frames are available, sort by frame number
                    if "frames" in group_data and len(group_data["frames"]) > 0:
                        frames = group_data["frames"]
                        files = group_data["files"]
                        
                        # Create sorted frames and files
                        # Make sure we have valid frame numbers
                        if not all(isinstance(frame, int) for frame in frames):
                            print(f"[WARNING] Invalid frame numbers in sequence, skipping group", file=sys.stderr)
                            single_files.extend(files)
                            continue
                            
                        frame_file_pairs = sorted(zip(frames, files), key=lambda x: x[0])
                        sorted_frames = [pair[0] for pair in frame_file_pairs]
                        sorted_files = [pair[1] for pair in frame_file_pairs]
                        
                        sequence = {
                            "type": "sequence",
                            "base_name": group_data["base_name"],
                            "suffix": group_data["suffix"],
                            "extension": group_data.get("extension", group_data["suffix"]),
                            "directory": group_data["directory"],
                            "files": sorted_files,
                            "frame_numbers": sorted_frames,
                            "frame_range": f"{min(sorted_frames)}-{max(sorted_frames)}",
                            "frame_count": len(sorted_files),
                            "size": group_data.get("size", 0),
                        }
                        
                        sequences.append(sequence)
                        
                        # Log only occasionally for large sets
                        if len(sequences) % 10 == 0 or len(sequences) < 10:
                            print(
                                f"  Sequence: {group_data['base_name']}.{group_data['suffix']} "
                                f"[{sequence['frame_range']}] ({sequence['frame_count']} frames)",
                                file=sys.stderr,
                            )
                    else:
                        # If frames aren't available, just process as single files
                        single_files.extend(group_data["files"])
                else:
                    # Groups with only one file go to single files
                    if len(group_data["files"]) == 1:
                        single_files.append(group_data["files"][0])
            except Exception as e:
                # If any error happens during finalization, add all files to singles as fallback
                print(f"[ERROR] Error finalizing sequence group {seq_key}: {e}", file=sys.stderr)
                if "files" in group_data and group_data["files"]:
                    single_files.extend(group_data["files"])
        
        # Final progress update
        if batch_id:
            self._update_mapping_progress(batch_id, len(file_groups), len(file_groups), status="sequences_grouped")

        print(
            f"[INFO] Final result: {len(sequences)} sequences, {len(single_files)} single files",
            file=sys.stderr,
        )
        return sequences, single_files


    
    def _extract_sequence_info(self, filename: str) -> Optional[Dict[str, Any]]:
        """Extract sequence information from a filename.
        Simple rule: A sequence is any file ending with .#####.<ext> where # is a digit.
        The frame number must be 1-10 digits, right before the final extension.
        
        Examples: 
        - name.0001.exr -> sequence with base_name='name', frame=1, suffix='.exr'
        - complex.name.with.dots.00001.exr -> sequence with base_name='complex.name.with.dots', frame=1, suffix='.exr'
        """
        # Safety checks for invalid filenames
        if not filename or not isinstance(filename, str):
            print(f"[SEQUENCE_DEBUG] Invalid filename: {filename} (type: {type(filename)})", file=sys.stderr)
            return None
            
        # Skip placeholder filenames
        if "sequence_" in filename or filename == "_####" or filename.endswith("_####"):
            print(f"[SEQUENCE_DEBUG] Skipping placeholder filename: {filename}", file=sys.stderr)
            return None
            
        print(f"[SEQUENCE_DEBUG] Extracting sequence info from: {filename}", file=sys.stderr)
        
        # Simple pattern: match any filename with digits before the last extension
        # This captures everything before the digits as base_name, the digits as frame, and the extension
        pattern = r"^(.+?)\.(\d{1,10})(\.[^.]+)$"
        
        try:
            match = re.match(pattern, filename, re.IGNORECASE)
            if match:
                base_name, frame_str, suffix = match.groups()
                print(f"[SEQUENCE_DEBUG] Sequence match: base={base_name}, frame={frame_str}, suffix={suffix}", file=sys.stderr)
                
                # Skip if the base_name is a placeholder or empty
                if not base_name or base_name == "_" or "sequence_" in base_name:
                    print(f"[SEQUENCE_DEBUG] Skipping placeholder base_name: {base_name}", file=sys.stderr)
                    return None
                
                try:
                    frame_num = int(frame_str)
                    return {
                        "base_name": base_name,
                        "frame": frame_num,
                        "suffix": suffix
                    }
                except ValueError:
                    print(f"[SEQUENCE_DEBUG] Failed to convert frame number: {frame_str}", file=sys.stderr)
        except Exception as e:
            print(f"[SEQUENCE_DEBUG] Error in sequence extraction: {e}", file=sys.stderr)
            
        return None

    def _create_sequence_mapping(
        self, sequence: Union[Dict[str, Any], List[Any]], profile: Dict[str, Any], original_base_name: str = None
    ) -> Dict[str, Any]:
        """Create a mapping for a sequence of files.
        
        This method can handle sequence objects that are either dictionaries with metadata
        or lists of files. It extracts the necessary information and creates a mapping.    
        """
        print(f"[DEBUG] Sequence type: {type(sequence)}", file=sys.stderr)
        
        # Extract the first file from the sequence
        first_file = None
        first_filename = ""
        first_filepath = ""
        # --- Mapping Extraction: Always use correct base_name ---
        # 1. Prefer base_name from sequence dict, else use original_base_name, else extract from first file
        base_name = ""
        extraction_source = ""
        # --- Handle multi-sequence input: list of dicts with base_name ---
        if isinstance(sequence, list) and len(sequence) > 0 and all(isinstance(item, dict) and 'base_name' in item for item in sequence):
            print(f"[MAPPING_DEBUG] Detected list of dicts with base_name (multi-sequence input), count: {len(sequence)}", file=sys.stderr)
            mappings = []
            for i, seq_dict in enumerate(sequence):
                print(f"[MAPPING_DEBUG] Processing sequence {i+1}/{len(sequence)} with base_name: {seq_dict.get('base_name')}", file=sys.stderr)
                mapping = self._create_sequence_mapping(seq_dict, profile, seq_dict.get('base_name'))
                if isinstance(mapping, list):
                    mappings.extend(mapping)
                elif mapping:
                    mappings.append(mapping)
            return mappings
        # --- Normal single-sequence logic ---
        if isinstance(sequence, dict):
            base_name = sequence.get("base_name", "")
            if base_name:
                extraction_source = base_name
                print(f"[MAPPING_DEBUG] Extracting mapping info from sequence['base_name']: '{base_name}'", file=sys.stderr)
            elif original_base_name:
                base_name = original_base_name
                extraction_source = base_name
                print(f"[MAPPING_DEBUG] Extracting mapping info from original_base_name: '{base_name}'", file=sys.stderr)
            elif "files" in sequence and sequence["files"]:
                first_file = sequence["files"][0]
                if isinstance(first_file, dict) and 'name' in first_file:
                    extraction_source = first_file['name']
                elif isinstance(first_file, str):
                    extraction_source = first_file
                print(f"[MAPPING_DEBUG][WARNING] base_name missing, extracting from first file: '{extraction_source}'", file=sys.stderr)
            else:
                extraction_source = ""
                print(f"[MAPPING_DEBUG][ERROR] No base_name or files in sequence dict", file=sys.stderr)
        elif isinstance(sequence, list) and len(sequence) > 0:
            # Try to extract from first file in list
            first_file = sequence[0]
            if isinstance(first_file, dict) and 'name' in first_file:
                extraction_source = first_file['name']
            elif isinstance(first_file, str):
                extraction_source = first_file
            print(f"[MAPPING_DEBUG] Extracting mapping info from first file in sequence list: '{extraction_source}'", file=sys.stderr)
        else:
            extraction_source = ""
            print(f"[MAPPING_DEBUG][ERROR] Sequence is neither dict nor list or is empty.", file=sys.stderr)

        if not extraction_source:
            extraction_source = ""
            print(f"[MAPPING_DEBUG][ERROR] No valid extraction source for mapping codes.", file=sys.stderr)

        # Extraction helpers (use existing methods or regexes)
        def safe_extract(method, label):
            try:
                if hasattr(self, method):
                    val = getattr(self, method)(extraction_source)
                    if val:
                        print(f"[MAPPING_DEBUG] Extracted {label}: {val}", file=sys.stderr)
                        return val
            except Exception as e:
                print(f"[MAPPING_DEBUG][WARNING] Failed to extract {label}: {e}", file=sys.stderr)
            return "unmatched"

        shot_code = safe_extract('_extract_shot_simple', 'shot_code')
        asset_code = safe_extract('_extract_asset_simple', 'asset_code')
        stage_code = safe_extract('_extract_stage_simple', 'stage_code')
        task_code = safe_extract('_extract_task_simple', 'task_code')
        version_code = safe_extract('_extract_version_simple', 'version_code')
        res_code = safe_extract('_extract_resolution_simple', 'res_code')
        # --- End: Mapping Extraction ---


        suffix = ""
        frame_range = ""
        frame_count = 0
        directory = ""
        ext = ""
        files_list = []
        
        # Store information about all sequence files for pattern analysis
        all_filenames = []
        
        try:
            # Handle different sequence formats
            if isinstance(sequence, dict):
                # Log the dictionary structure for debugging
                print(f"[DEBUG] Sequence dictionary keys: {list(sequence.keys())}", file=sys.stderr)
                
                # It's a dictionary with metadata and files
                if "files" in sequence and sequence["files"]:
                    if isinstance(sequence["files"], list) and len(sequence["files"]) > 0:
                        print(f"[DEBUG] Found files list with {len(sequence['files'])} items", file=sys.stderr)
                        # Sample the first few files for debugging
                        for i, file_item in enumerate(sequence["files"][:3]):
                            if isinstance(file_item, str):
                                print(f"[DEBUG] File item {i} (str): {file_item}", file=sys.stderr)
                            elif isinstance(file_item, dict):
                                print(f"[DEBUG] File item {i} (dict) keys: {list(file_item.keys())}", file=sys.stderr)
                                if 'name' in file_item:
                                    print(f"[DEBUG] File item {i} name: {file_item['name']}", file=sys.stderr)
                                elif 'path' in file_item:
                                    print(f"[DEBUG] File item {i} path: {file_item['path']}", file=sys.stderr)
                        first_file = sequence["files"][0]
                        files_list = sequence["files"]
                
                # Extract metadata from dictionary
                base_name = sequence.get("base_name", "")
                print(f"[DEBUG] Dictionary contains base_name: {base_name}", file=sys.stderr)
                
                suffix = sequence.get("suffix", "")
                frame_range = sequence.get("frame_range", "")
                frame_count = sequence.get("frame_count", 0)
                directory = sequence.get("directory", "")
                ext = sequence.get("extension", "")
                
                # Try to get names from other properties
                if not base_name and sequence.get("name"):
                    name = sequence.get("name")
                    print(f"[DEBUG] Using sequence name as base: {name}", file=sys.stderr)
                    # Extract base_name from name if it's a sequence pattern
                    seq_info = self._extract_sequence_info(name)
                    if seq_info and seq_info.get("base_name"):
                        base_name = seq_info.get("base_name")
                    else:
                        # If not a sequence pattern, use the name as is
                        base_name = name
            
            elif isinstance(sequence, list) and len(sequence) > 0:
                # It's a list of files
                files_list = sequence
                print(f"[DEBUG] Sequence as list with {len(sequence)} files", file=sys.stderr)
                # Debug the actual content of the list to see what we're working with
                for i, item in enumerate(sequence[:5]):  # Show first 5 items to avoid excessive logs
                    if isinstance(item, str):
                        print(f"[DEBUG] Sequence list item {i}: {item}", file=sys.stderr)
                    elif isinstance(item, dict):
                        # Print full dict details to see what's available
                        print(f"[DEBUG] Sequence list item {i} (dict) keys: {list(item.keys())}", file=sys.stderr)
                        # Check for common filename properties
                        found_name = None
                        for key in ['name', 'filename', 'file', 'path', 'filepath']:
                            if key in item and item[key]:
                                found_name = item[key]
                                print(f"[DEBUG] Found name in '{key}': {found_name}", file=sys.stderr)
                                break
                        if not found_name:
                            print(f"[DEBUG] Dict values: {list(item.values())[:3]}...", file=sys.stderr)
                    else:
                        print(f"[DEBUG] Sequence list item {i} unknown type: {type(item)}", file=sys.stderr)
                
                # Make sure we have a valid first file
                if len(sequence) > 0:
                    # Get the first non-empty file that has a proper name
                    first_file = None
                    
                    # First pass: collect all filenames for pattern analysis
                    base_name_candidates = {}
                    
                    # Before checking individual files, see if we can extract from the whole sequence
                    if len(sequence) > 0:
                        # See if any of the sequence files have a common pattern
                        real_filenames = []
                        real_filepaths = []
                        
                        # Extract all available filenames/paths from the sequence items
                        for file_item in sequence:
                            if isinstance(file_item, str) and file_item:
                                # For string items, try to extract the basename
                                if os.path.basename(file_item):
                                    filename = os.path.basename(file_item)
                                    real_filenames.append(filename)
                                    real_filepaths.append(file_item)
                                    print(f"[DEBUG] Found filename from string: {filename}", file=sys.stderr)
                            elif isinstance(file_item, dict):
                                # For dictionary items, check various possible keys
                                found_name = None
                                found_path = None
                                
                                # First, print dict keys to help debug
                                if file_item:
                                    print(f"[DEBUG] Dictionary keys: {list(file_item.keys())}", file=sys.stderr)
                                    # If there are only a few keys, print the full dict for debugging
                                    if len(file_item.keys()) <= 5:
                                        print(f"[DEBUG] Full dictionary content: {file_item}", file=sys.stderr)
                                
                                # Check various name keys
                                for name_key in ['name', 'filename', 'file', 'basename', 'Name', 'FileName', 'File']:
                                    if name_key in file_item and file_item[name_key]:
                                        found_name = file_item[name_key]
                                        if isinstance(found_name, str) and found_name:
                                            print(f"[DEBUG] Found filename in dict key '{name_key}': {found_name}", file=sys.stderr)
                                            break
                                
                                # Check various path keys
                                for path_key in ['path', 'filepath', 'fullpath', 'source', 'sourcePath', 'Path', 'FilePath', 'FullPath', 'Source', 'SourcePath']:
                                    if path_key in file_item and file_item[path_key]:
                                        found_path = file_item[path_key]
                                        if isinstance(found_path, str) and found_path:
                                            print(f"[DEBUG] Found filepath in dict key '{path_key}': {found_path}", file=sys.stderr)
                                            break
                                            
                                # If we have source and target paths, also check those
                                if 'sourcePath' in file_item and isinstance(file_item['sourcePath'], str):
                                    found_path = file_item['sourcePath']
                                    print(f"[DEBUG] Found sourcePath: {found_path}", file=sys.stderr)
                                    if not found_name and os.path.basename(found_path):
                                        found_name = os.path.basename(found_path)
                                        print(f"[DEBUG] Extracted name from sourcePath: {found_name}", file=sys.stderr)
                                
                                # Try to get filename from path if we have path but no name
                                if not found_name and found_path and os.path.basename(found_path):
                                    found_name = os.path.basename(found_path)
                                    print(f"[DEBUG] Extracted filename from path: {found_name}", file=sys.stderr)
                                
                                # If we found a usable name, add it to our list
                                if found_name:
                                    real_filenames.append(found_name)
                                    if found_path:
                                        real_filepaths.append(found_path)
                                
                                # Last resort: try to find first string value in dict
                                if not found_name:
                                    for key, val in file_item.items():
                                        if isinstance(val, str) and val and '.' in val:
                                            # Check if it looks like a filename (has extension)
                                            if os.path.basename(val) == val or len(os.path.basename(val)) > 5:
                                                print(f"[DEBUG] Found possible filename in value of '{key}': {val}", file=sys.stderr)
                                                real_filenames.append(val)
                                                break
                        
                        print(f"[DEBUG] Analyzing {len(real_filenames)} real filenames for patterns", file=sys.stderr)
                        if real_filenames:
                            # Print a few sample filenames
                            for i, fname in enumerate(real_filenames[:3]):
                                print(f"[DEBUG] Sample filename {i}: {fname}", file=sys.stderr)
                    
                    for potential_file in sequence:
                        if potential_file:  # Make sure it's not None or empty
                            # Extract filename depending on type
                            if isinstance(potential_file, str) and os.path.basename(potential_file):
                                filename = os.path.basename(potential_file)
                                all_filenames.append(filename)
                                
                                # Check if the filename matches our sequence pattern
                                seq_info = self._extract_sequence_info(filename)
                                if seq_info and seq_info.get("base_name"):
                                    # Count occurrences of each base_name pattern
                                    base_name_pattern = seq_info.get("base_name")
                                    base_name_candidates[base_name_pattern] = base_name_candidates.get(base_name_pattern, 0) + 1
                                    print(f"[DEBUG] Found potential base_name: {base_name_pattern} in {filename}", file=sys.stderr)
                                    
                            elif isinstance(potential_file, dict) and potential_file.get('name'):
                                filename = potential_file.get('name')
                                all_filenames.append(filename)
                                
                                # Check if the filename matches our sequence pattern
                                seq_info = self._extract_sequence_info(filename)
                                if seq_info and seq_info.get("base_name"):
                                    # Count occurrences of each base_name pattern
                                    base_name_pattern = seq_info.get("base_name")
                                    base_name_candidates[base_name_pattern] = base_name_candidates.get(base_name_pattern, 0) + 1
                                    print(f"[DEBUG] Found potential base_name in dict: {base_name_pattern} in {filename}", file=sys.stderr)
                                
                                # Sometimes the dict might contain an explicit base_name - check that too
                                if potential_file.get('base_name'):
                                    explicit_base = potential_file.get('base_name')
                                    if explicit_base and explicit_base != "_" and "sequence_" not in explicit_base:
                                        print(f"[DEBUG] Found explicit base_name in dict: {explicit_base}", file=sys.stderr)
                                        base_name_candidates[explicit_base] = base_name_candidates.get(explicit_base, 0) + 5  # Higher weight
                    
                    # Identify the most common base_name pattern
                    if base_name_candidates:
                        most_common_base = max(base_name_candidates.items(), key=lambda x: x[1])[0]
                        if not base_name:  # Only use if we don't already have a base_name
                            base_name = most_common_base
                            print(f"[DEBUG] Found most common base_name pattern: {base_name} (appeared {base_name_candidates[base_name]} times)", file=sys.stderr)
                    
                    # Second pass: find a good first file
                    for potential_file in sequence:
                        if potential_file:  # Make sure it's not None or empty
                            if isinstance(potential_file, str) and os.path.basename(potential_file):
                                filename = os.path.basename(potential_file)
                                # Check if the filename matches our sequence pattern
                                seq_info = self._extract_sequence_info(filename)
                                if seq_info and seq_info.get("base_name") == base_name:
                                    # This is a good candidate with proper sequence info matching our most common pattern
                                    first_file = potential_file
                                    print(f"[DEBUG] Found first valid file in sequence with matching pattern: {filename}", file=sys.stderr)
                                    break
                                elif seq_info and seq_info.get("base_name"):
                                    # This is a good candidate with proper sequence info
                                    first_file = potential_file
                                    print(f"[DEBUG] Found first valid file in sequence with good pattern: {filename}", file=sys.stderr)
                                    # Continue searching for better matches
                                else:
                                    # Still a valid file, but save it only if we don't find better matches
                                    if not first_file:
                                        first_file = potential_file
                                        print(f"[DEBUG] Found first valid file in sequence: {filename}", file=sys.stderr)
                                    # Continue searching for better candidates
                            elif isinstance(potential_file, dict) and potential_file.get('name'):
                                filename = potential_file.get('name')
                                # Check if the filename matches our sequence pattern
                                seq_info = self._extract_sequence_info(filename)
                                if seq_info and seq_info.get("base_name") == base_name:
                                    # This is a good candidate with proper sequence info matching our most common pattern
                                    first_file = potential_file
                                    print(f"[DEBUG] Found first valid file in sequence dict with matching pattern: {filename}", file=sys.stderr)
                                    break
                                elif seq_info and seq_info.get("base_name"):
                                    # This is a good candidate with proper sequence info
                                    first_file = potential_file
                                    print(f"[DEBUG] Found first valid file in sequence dict with good pattern: {filename}", file=sys.stderr)
                                    # Continue searching for better matches
                                else:
                                    # Still a valid file, but save it only if we don't find better matches
                                    if not first_file:
                                        first_file = potential_file
                                        print(f"[DEBUG] Found first valid file in sequence dict: {filename}", file=sys.stderr)
                                    # Continue searching for better candidates
                    
                    # If we couldn't find a valid file, use the first one anyway
                    if first_file is None and len(sequence) > 0:
                        first_file = sequence[0]
                        print(f"[DEBUG] Using first file in sequence despite being potentially invalid", file=sys.stderr)
                
                # We need to extract sequence metadata from the first file
                if first_file:
                    if isinstance(first_file, str):
                        # File is a path string
                        first_filename = os.path.basename(first_file)
                        first_filepath = first_file
                        directory = os.path.dirname(first_file)
                    elif isinstance(first_file, dict):
                        # File is a dictionary with details
                        first_filename = first_file.get("name", "")
                        first_filepath = first_file.get("path", "")
                        if first_filepath:
                            directory = os.path.dirname(first_filepath)
                    
                    # Try to extract sequence information from the filename
                    seq_info = self._extract_sequence_info(first_filename)
                    if seq_info:
                        base_name = seq_info.get("base_name", "")
                        suffix = seq_info.get("suffix", "")
                    
                    # Calculate frame range and count from all files
                    frame_count = len(sequence)
                    frame_numbers = []
                    
                    # Extract frame numbers from all files in the sequence
                    # This allows us to get the complete frame range even if some files don't match the sequence pattern
                    for file_item in sequence:
                        file_name = ""
                        if isinstance(file_item, str):
                            file_name = os.path.basename(file_item)
                        elif isinstance(file_item, dict) and "name" in file_item:
                            file_name = file_item.get("name", "")
                            
                        if file_name:
                            file_seq_info = self._extract_sequence_info(file_name)
                            if file_seq_info and "frame" in file_seq_info:
                                frame_number = file_seq_info["frame"]
                                frame_numbers.append(frame_number)
                    
                    if frame_numbers:
                        min_frame = min(frame_numbers)
                        max_frame = max(frame_numbers)
                        frame_range = f"{min_frame}-{max_frame}"
                        print(f"[DEBUG] Extracted frame numbers from list sequence: {len(frame_numbers)} frames (range: {min_frame}-{max_frame})", file=sys.stderr)
                        
                        # Store frame numbers for later use
                        self.current_frame_numbers = frame_numbers
                        
                        # Extract the first and last frame file to better identify the sequence
                        min_frame_file = None
                        max_frame_file = None
                        for file_item in sequence:
                            file_name = ""
                            if isinstance(file_item, str):
                                file_name = os.path.basename(file_item)
                                file_path = file_item
                            elif isinstance(file_item, dict) and "name" in file_item:
                                file_name = file_item.get("name", "")
                                file_path = file_item.get("path", "")
                            
                            if file_name:
                                file_seq_info = self._extract_sequence_info(file_name)
                                if file_seq_info and "frame" in file_seq_info:
                                    if file_seq_info["frame"] == min_frame and not min_frame_file:
                                        min_frame_file = file_item
                                    if file_seq_info["frame"] == max_frame and not max_frame_file:
                                        max_frame_file = file_item
                        
                        # Use the first frame file for better base_name extraction if we haven't got one yet
                        if not base_name and min_frame_file:
                            if isinstance(min_frame_file, str):
                                min_filename = os.path.basename(min_frame_file)
                            elif isinstance(min_frame_file, dict) and "name" in min_frame_file:
                                min_filename = min_frame_file.get("name", "")
                                
                            if min_filename:
                                min_seq_info = self._extract_sequence_info(min_filename)
                                if min_seq_info and min_seq_info.get("base_name"):
                                    base_name = min_seq_info.get("base_name")
                                    suffix = min_seq_info.get("suffix", "")
                                    print(f"[DEBUG] Using first frame file for base_name: {base_name}", file=sys.stderr)
                    
                    # Get file extension
                    _, file_ext = os.path.splitext(first_filename)
                    ext = file_ext.lstrip('.')
                    
        except Exception as e:
            print(f"[ERROR] Failed to extract sequence info: {str(e)}", file=sys.stderr)
            # Create a placeholder mapping
            return {
                "source": "unknown",
                "destination": "unknown",
                "reason": f"Failed to process sequence: {str(e)}"
            }
    
        # If we couldn't extract a file, return a placeholder
        if first_file is None:
            print(f"[WARNING] No files found in sequence", file=sys.stderr)
            return {
                "source": "unknown",
                "destination": "unknown",
                "reason": "No files in sequence"
            }
    
        # Extract file information if not already done
        if not first_filename or not first_filepath:
            if isinstance(first_file, str):
                # It's just a path string
                first_filename = os.path.basename(first_file)
                first_filepath = first_file
                print(f"[DEBUG] Sequence mapping for path: {first_filename}", file=sys.stderr)
            else:
                # It's a dictionary with file details
                first_filename = first_file.get("name", "")
                first_filepath = first_file.get("path", "")
                print(f"[DEBUG] Sequence mapping for: {first_filename}", file=sys.stderr)
    
        # Extract metadata for the mapping
        shot = self._extract_shot_simple(first_filename, first_filepath)
        task = self._extract_task_simple(first_filename, first_filepath)
        print(f"[DEBUG] Extracted task: {task}", file=sys.stderr)
        version = self._extract_version_simple(first_filename)
        resolution = self._extract_resolution_simple(first_filename, first_filepath)
        asset = self._extract_asset_simple(first_filename)
        stage = self._extract_stage_simple(first_filename)
        print(f"[DEBUG] Sequence: {first_filename}", file=sys.stderr)
        print(f"  Extracted asset: {asset}", file=sys.stderr)
        print(f"  Extracted stage: {stage}", file=sys.stderr)
        print(f"  Extracted task: {task}", file=sys.stderr)
        
        # Make sure we have valid base_name and suffix for the filename pattern
        if not base_name and first_filename:
            # If we couldn't extract base_name but have a filename, use it as the base
            print(f"[DEBUG] Using first_filename as base_name: {first_filename}", file=sys.stderr)
            # Remove extension if present
            if '.' in first_filename:
                base_part = first_filename.rsplit('.', 1)[0]
                # If it has a frame number, remove that too
                if base_part and base_part[-1].isdigit():
                    # Find where the numbers start from the end
                    i = len(base_part) - 1
                    while i >= 0 and base_part[i].isdigit():
                        i -= 1
                    if i >= 0 and (base_part[i] == '.' or base_part[i] == '_'):
                        base_name = base_part[:i]
                    else:
                        base_name = base_part
                else:
                    base_name = base_part
            else:
                base_name = first_filename
            
            # Extract extension if present
            if '.' in first_filename:
                ext = first_filename.rsplit('.', 1)[1]
                suffix = '.' + ext  # Default suffix to include the dot and extension
            else:
                ext = ""
                suffix = ""
                
            print(f"[DEBUG] Extracted from filename - base_name: {base_name}, suffix: {suffix}, ext: {ext}", file=sys.stderr)
        
        # Ensure we have valid names by falling back to defaults if needed
        if not base_name:
            print(f"[WARNING] Could not extract base_name, using default", file=sys.stderr)
            base_name = "sequence"  # Default base name
            
        # Create sequence filename pattern
        if suffix.endswith(ext) and ext:
            sequence_filename = (
                f"{base_name}.####{suffix}"
                if "." in suffix
                else f"{base_name}_####{suffix}"
            )
        else:
            sequence_filename = (
                f"{base_name}.####{suffix}{ext}"
                if "." in suffix
                else f"{base_name}_####{suffix}{ext}"
            )

        # Create sequence pattern for source
        if "." in suffix:
            sequence_pattern = f"{base_name}.####{suffix}"
        else:
            sequence_pattern = f"{base_name}_####{suffix}"
            
        # Ensure we have a valid directory
        if not directory and first_filepath:
            directory = os.path.dirname(first_filepath)
        elif not directory:
            directory = os.getcwd()  # Default to current directory if none found
            
        source_pattern = os.path.join(directory, sequence_pattern)
        print(f"[DEBUG] Sequence filename: {sequence_filename}, pattern: {sequence_pattern}", file=sys.stderr)
        
        # Generate target path
        vfx_root = profile.get("vfxRootPath", "/vfx/projects/default")
        target_path = self._generate_simple_target_path(
            vfx_root,
            shot,
            asset,
            stage,
            task,
            version,
            resolution,
            sequence_filename,
            profile,
        )
        print(f"  Target path: {target_path}", file=sys.stderr)
        
        # Determine mapping status
        if shot and task and version:
            status = "auto"
        else:
            status = "manual"
        
        # Process and validate files
        total_size = 0
        validated_files = []
        
        # Use the files list we extracted earlier
        for file_node in files_list:
            # Handle both string paths and dictionary objects
            if isinstance(file_node, str):
                # It's a string path
                file_path = file_node
                file_name = os.path.basename(file_path)
                file_size = 0
                try:
                    # Try to get file size if the file is accessible
                    if os.path.exists(file_path):
                        file_size = os.path.getsize(file_path)
                except Exception as e:
                    print(f"[WARNING] Could not get file size for {file_path}: {e}", file=sys.stderr)
                    
                # Get extension
                _, file_ext = os.path.splitext(file_name)
                file_ext = file_ext.lstrip('.')
                
                validated_file = {
                    "name": file_name,
                    "path": file_path,
                    "type": "file",
                    "size": file_size,
                    "extension": file_ext,
                }
            else:
                # It's a dictionary with file details
                validated_file = {
                    "name": file_node.get("name", "unknown_file"),
                    "path": file_node.get("path", ""),
                    "type": file_node.get("type", "file"),
                    "size": file_node.get("size", 0),
                    "extension": file_node.get("extension", ""),
                }
            
            validated_files.append(validated_file)
            total_size += validated_file["size"]
        
        # Add start/end to sequence dict for backend compatibility
        frame_numbers_list = []
        if isinstance(sequence, dict):
            frame_numbers_list = sequence.get("frame_numbers", [])
        elif hasattr(self, 'current_frame_numbers'):
            frame_numbers_list = self.current_frame_numbers
        
        print(f"[DEBUG] Frame numbers for sequence dict: {len(frame_numbers_list)} numbers available", file=sys.stderr)
        
        seq_dict = {
            "base_name": base_name,
            "frame_range": frame_range,
            "frame_count": frame_count,
            "total_size": total_size,
            "files": validated_files,
            "frame_numbers": frame_numbers_list,
        }
        
        # Use frame_numbers_list we already prepared
        if frame_numbers_list:
            try:
                seq_dict["start"] = min(frame_numbers_list)
                seq_dict["end"] = max(frame_numbers_list)
                # We already set frame_numbers in seq_dict above
                print(f"[DEBUG] Using {len(frame_numbers_list)} frame numbers (start={seq_dict['start']}, end={seq_dict['end']})", file=sys.stderr)
            except Exception as e:
                print(f"[WARNING] Could not extract min/max from frame numbers: {e}", file=sys.stderr)
        else:
            print(f"[WARNING] No frame numbers available for sequence", file=sys.stderr)
        
        # Create the final mapping structure
        print(f"[DEBUG] Creating sequence mapping with {len(validated_files)} files, {frame_count} frames", file=sys.stderr)
        
        # Double-check sequence filename and source pattern for validity
        if sequence_filename == "_####" or sequence_filename == "_####." or not base_name:
            # Check if we have a base_name from our filename analysis
            if not base_name and all_filenames:
                # Analyze all filenames to find the most common pattern
                filename_patterns = {}
                
                # First try the standard sequence pattern extraction
                for filename in all_filenames:
                    if filename:
                        print(f"[DEBUG] Analyzing filename for pattern: {filename}", file=sys.stderr)
                        seq_info = self._extract_sequence_info(filename)
                        if seq_info and seq_info.get("base_name"):
                            pattern = seq_info.get("base_name")
                            filename_patterns[pattern] = filename_patterns.get(pattern, 0) + 1
                            print(f"[DEBUG] Found pattern in filename analysis: {pattern}", file=sys.stderr)
                
                # If we couldn't find any patterns with the standard approach, try a more permissive approach
                if not filename_patterns and all_filenames:
                    print(f"[DEBUG] No standard sequence patterns found, trying fallback approach with {len(all_filenames)} files", file=sys.stderr)
                    
                    # Extract common prefix from filenames as a fallback
                    sample_names = [name for name in all_filenames if name and isinstance(name, str)]
                    if sample_names:
                        # Remove numbers and extensions to find common base
                        cleaned_names = []
                        for name in sample_names:
                            # Remove extension and trailing numbers
                            base = os.path.splitext(name)[0]
                            # Remove trailing digits
                            base = re.sub(r'\d+$', '', base)
                            cleaned_names.append(base)
                        
                        if cleaned_names:
                            # Find the most common base name
                            name_counts = {}
                            for name in cleaned_names:
                                name_counts[name] = name_counts.get(name, 0) + 1
                            
                            if name_counts:
                                most_common = max(name_counts.items(), key=lambda x: x[1])
                                common_base = most_common[0]
                                if common_base and common_base != "_" and "sequence_" not in common_base:
                                    print(f"[DEBUG] Found common base from cleaned names: {common_base} (appeared {most_common[1]} times)", file=sys.stderr)
                                    filename_patterns[common_base] = most_common[1]
                
                if filename_patterns:
                    # Use the most common pattern as our base_name
                    most_common_pattern = max(filename_patterns.items(), key=lambda x: x[1])[0]
                    base_name = most_common_pattern
                    print(f"[DEBUG] Using most common pattern as base_name: {base_name} (appeared in {filename_patterns[base_name]} files)", file=sys.stderr)
                    
                    # Also extract a proper suffix from a matching file
                    for filename in all_filenames:
                        seq_info = self._extract_sequence_info(filename)
                        if seq_info and seq_info.get("base_name") == base_name:
                            suffix = seq_info.get("suffix", "")
                            if "." in suffix:
                                ext = suffix.lstrip('.')
                            break
            
            # We have a generic placeholder - try to create a better name
            if first_filename:
                # Set sequence filename from the first actual file
                base_without_frame = first_filename
                # Remove frame number if present
                seq_info = self._extract_sequence_info(first_filename)
                if seq_info and seq_info.get("base_name"):
                    base_without_frame = seq_info.get("base_name")
                    
                # Use the base_name we extracted from filename analysis if available
                if base_name:
                    base_without_frame = base_name
                    
                # Create proper sequence name with placeholders
                if ext:
                    sequence_filename = f"{base_without_frame}.####.{ext}"
                else:
                    sequence_filename = f"{base_without_frame}.####"
                    
                print(f"[DEBUG] Improved sequence filename from first file: {sequence_filename}", file=sys.stderr)
                
                # Also improve the source pattern if it's just a placeholder
                if source_pattern == "_####" or os.path.basename(source_pattern) == "_####" or "sequence_####" in source_pattern:
                    if first_filepath:
                        directory = os.path.dirname(first_filepath)
                        source_pattern = os.path.join(directory, sequence_filename)
                        print(f"[DEBUG] Improved source pattern: {source_pattern}", file=sys.stderr)
        
        # Use the extension we extracted earlier
        sequence_extension = ""
        if isinstance(sequence, dict):
            sequence_extension = sequence.get("extension", "")
        else:
            sequence_extension = ext
        
        # Ensure we have frame numbers in the sequence dict
        if hasattr(self, 'current_frame_numbers') and self.current_frame_numbers:
            seq_dict["frame_numbers"] = self.current_frame_numbers
            # Also set start/end if we have frame numbers
            seq_dict["start"] = min(self.current_frame_numbers)
            seq_dict["end"] = max(self.current_frame_numbers)
            # Ensure frame_count reflects actual frame numbers
            if len(self.current_frame_numbers) > frame_count:
                frame_count = len(self.current_frame_numbers)
                seq_dict["frame_count"] = frame_count
            print(f"[DEBUG] Set frame numbers from current_frame_numbers: {len(self.current_frame_numbers)}", file=sys.stderr)
                
        # Ensure we have a display name with actual content
        display_name = f"{base_name} [{frame_range}] ({frame_count} frames)"
        if not base_name and first_filename:
            # Create a display name based on the first filename if base_name is empty
            display_name = f"{os.path.basename(first_filename)} (sequence with {frame_count} frames)"
            
        # Only use sequence_filename if it's a real filename, not a placeholder
        if sequence_filename == "_####" or sequence_filename == "sequence_####" or "sequence_####" in sequence_filename:
            if base_name:
                # Create a proper sequence name with the detected base_name
                if ext:
                    better_filename = f"{base_name}.####.{ext}"
                else:
                    better_filename = f"{base_name}.####"
                print(f"[DEBUG] Replacing placeholder sequence filename with: {better_filename}", file=sys.stderr)
                sequence_filename = better_filename
                # Also update source pattern if it's generic
                if source_pattern == "_####" or "sequence_####" in source_pattern:
                    source_dir = os.path.dirname(source_pattern)
                    source_pattern = os.path.join(source_dir, sequence_filename)
                    print(f"[DEBUG] Updated source pattern to: {source_pattern}", file=sys.stderr)
        
        # Create mapping for this sequence
        seq_dict = {
            "id": str(uuid.uuid4()),
            "name": sequence_filename,
            "type": "sequence",
            "sourcePath": source_pattern,
            "targetPath": target_path,
            "status": "auto",
            "shot": shot_code,
            "asset": asset_code,
            "stage": stage_code,
            "task": task_code,
            "version": version_code,
            "resolution": res_code,
            "frame_count": frame_count,
            "base_name": base_name  # Store the base_name for later use
        }
        
        # Create the final sequence mapping result
        result = {
            "id": str(uuid.uuid4()),
            "name": sequence_filename,
            "type": "sequence",
            "sourcePath": source_pattern,
            "targetPath": target_path,
            "status": "auto",
            "shot": shot_code,
            "asset": asset_code,
            "stage": stage_code,
            "task": task_code,
            "version": version_code,
            "resolution": res_code,
            "node": {
                "name": sequence_filename,
                "path": source_pattern,
                "type": "sequence",
                "size": total_size,
                "extension": sequence_extension,
                "children": [],
            },
            "sequence": seq_dict,
            "displayName": display_name,
        }
        
        print(f"[DEBUG] Final sequence mapping created with name={sequence_filename}, {len(seq_dict.get('frame_numbers', []))} frame numbers", file=sys.stderr)
        return result

    def _create_simple_mapping(
        self, node: Dict[str, Any], profile: Dict[str, Any]
    ) -> Dict[str, Any]:
        filename = node.get("name", "")
        print(f"[DEBUG] Simple mapping for: {filename}", file=sys.stderr)
        source_path = node.get("path", "")
        shot = self._extract_shot_simple(filename, source_path)
        task = self._extract_task_simple(filename, source_path)
        print(f"[DEBUG] Extracted task: {task}", file=sys.stderr)
        version = self._extract_version_simple(filename)
        resolution = self._extract_resolution_simple(filename, source_path)
        asset = self._extract_asset_simple(filename)
        stage = self._extract_stage_simple(filename)
        print(f"[DEBUG] File: {filename}", file=sys.stderr)
        print(f"  Extracted asset: {asset}", file=sys.stderr)
        print(f"  Extracted stage: {stage}", file=sys.stderr)
        print(f"  Extracted task: {task}", file=sys.stderr)
        vfx_root = profile.get("vfxRootPath", "/vfx/projects/default")
        target_path = self._generate_simple_target_path(
            vfx_root, shot, asset, stage, task, version, resolution, filename, profile
        )
        print(f"  Target path: {target_path}", file=sys.stderr)
        if shot and task and version:
            status = "auto"
        else:
            status = "manual"
        validated_node = {
            "name": node.get("name", "unknown_file"),
            "path": node.get("path", ""),
            "type": node.get("type", "file"),
            "size": node.get("size", 0),
            "extension": node.get("extension", ""),
        }
        return {
            "id": str(uuid.uuid4()),
            "name": filename,
            "sourcePath": source_path,
            "targetPath": target_path,
            "status": status,
            "shot": shot,
            "asset": asset,
            "stage": stage,
            "task": task,
            "version": version,
            "resolution": resolution,
            "node": validated_node,
        }

    def _generate_simple_target_path(
        self,
        vfx_root: str,
        shot: Optional[str],
        asset: Optional[str],
        stage: Optional[str],
        task: Optional[str],
        version: Optional[str],
        resolution: Optional[str],
        filename: str,
        profile: Dict[str, Any],
    ) -> str:
        import os

        profile_name = profile.get("name", "").lower()
        config_types = self.config.get("projectTypes", {})
        is_sphere = "sphere" in profile_name
        vfx_folder = config_types.get("sphere", {}).get("vfxFolder", "04_vfx")
        normal_3d_folder = "3D"
        vfx_parts = []
        if is_sphere:
            vfx_parts.append(vfx_folder)
        else:
            vfx_parts.append(normal_3d_folder)
        vfx_parts.append(shot if shot else "unmapped")
        vfx_parts.append(asset if asset else "unmapped")
        vfx_parts.append(stage if stage else "unmapped")
        vfx_parts.append(task if task else "unmatched")
        vfx_parts.append(version if version else "unmatched")
        vfx_parts.append(resolution if resolution else "unmatched")
        vfx_parts.append(filename)
        vfx_rel_path = os.path.join(*vfx_parts)
        if os.path.isabs(vfx_root):
            target_path = os.path.join(vfx_root, vfx_rel_path)
        else:
            target_path = os.path.join(vfx_root, vfx_rel_path)
        if os.name == "nt":
            target_path = target_path.replace("/", "\\")
        return target_path

    def _create_simple_mapping(
        self, node: Dict[str, Any], profile: Dict[str, Any]
    ) -> Dict[str, Any]:
        filename = node.get("name", "")
        print(f"[DEBUG] Simple mapping for: {filename}", file=sys.stderr)
        source_path = node.get("path", "")
        shot = self._extract_shot_simple(filename, source_path)
        task = self._extract_task_simple(filename, source_path)
        print(f"[DEBUG] Extracted task: {task}", file=sys.stderr)
        version = self._extract_version_simple(filename)
        resolution = self._extract_resolution_simple(filename, source_path)
        asset = self._extract_asset_simple(filename)
        stage = self._extract_stage_simple(filename)
        print(f"[DEBUG] File: {filename}", file=sys.stderr)
        print(f"  Extracted asset: {asset}", file=sys.stderr)
        print(f"  Extracted stage: {stage}", file=sys.stderr)
        print(f"  Extracted task: {task}", file=sys.stderr)
        vfx_root = profile.get("vfxRootPath", "/vfx/projects/default")
        target_path = self._generate_simple_target_path(
            vfx_root, shot, asset, stage, task, version, resolution, filename, profile
        )
        print(f"  Target path: {target_path}", file=sys.stderr)
        if shot and task and version:
            status = "auto"
        else:
            status = "manual"
        validated_node = {
            "name": node.get("name", "unknown_file"),
            "path": node.get("path", ""),
            "type": node.get("type", "file"),
            "size": node.get("size", 0),
            "extension": node.get("extension", ""),
        }
        return {
            "id": str(uuid.uuid4()),
            "name": filename,
            "sourcePath": source_path,
            "targetPath": target_path,
            "status": status,
            "shot": shot,
            "asset": asset,
            "stage": stage,
            "task": task,
            "version": version,
            "resolution": resolution,
            "node": validated_node,
        }

    def _generate_simple_target_path(
        self,
        vfx_root: str,
        shot: Optional[str],
        asset: Optional[str],
        stage: Optional[str],
        task: Optional[str],
        version: Optional[str],
        resolution: Optional[str],
        filename: str,
        profile: Dict[str, Any],
    ) -> str:
        import os

        profile_name = profile.get("name", "").lower()
        config_types = self.config.get("projectTypes", {})
        is_sphere = "sphere" in profile_name
        vfx_folder = config_types.get("sphere", {}).get("vfxFolder", "04_vfx")
        normal_3d_folder = "3D"
        vfx_parts = []
        if is_sphere:
            vfx_parts.append(vfx_folder)
        else:
            vfx_parts.append(normal_3d_folder)
        vfx_parts.append(shot if shot else "unmapped")
        vfx_parts.append(asset if asset else "unmapped")
        vfx_parts.append(stage if stage else "unmapped")
        vfx_parts.append(task if task else "unmatched")
        vfx_parts.append(version if version else "unmatched")
        vfx_parts.append(resolution if resolution else "unmatched")
        vfx_parts.append(filename)
        vfx_rel_path = os.path.join(*vfx_parts)
        if os.path.isabs(vfx_root):
            target_path = os.path.join(vfx_root, vfx_rel_path)
        else:
            target_path = os.path.join(vfx_root, vfx_rel_path)
        if os.name == "nt":
            target_path = target_path.replace("/", "\\")
        return target_path
